{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-66c042eb3967b9260b84a2d95d82485542b713ed",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Invoice/Invoice.sol": "project/contracts/Invoice/Invoice.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/Invoice/Invoice.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n\r\ncontract InvoiceManager is ReentrancyGuard {\r\n    // Item\r\n    struct Item {\r\n        string description;\r\n        uint256 quantity;\r\n        uint256 unitPrice;\r\n    }\r\n\r\n    // Invoice\r\n    struct Invoice {\r\n        address owner;\r\n        address payer;\r\n        uint256 id;\r\n        string title;\r\n        bool paid;\r\n        Item[] items;\r\n    }\r\n\r\n    // Mapping for invoices\r\n    mapping(uint256 => Invoice) public invoices;\r\n    mapping(address => uint256[]) private ownerInvoices;\r\n    mapping(address => uint256[]) private attributedInvoice;\r\n    uint256 public nextInvoiceId;\r\n\r\n    // Get invoice\r\n    function getInvoice(\r\n        uint256 invoiceId\r\n    ) external view returns (Invoice memory) {\r\n        return invoices[invoiceId];\r\n    }\r\n\r\n    // Create a new invoice\r\n    function createInvoice(\r\n        string memory title,\r\n        Item[] memory items,\r\n        address payer\r\n    ) public {\r\n        uint256 invoiceId = nextInvoiceId++;\r\n        Invoice storage inv = invoices[invoiceId];\r\n        inv.owner = msg.sender;\r\n        inv.id = invoiceId;\r\n\r\n        // Payer\r\n        inv.payer = payer;\r\n        attributedInvoice[payer].push(invoiceId);\r\n\r\n        inv.title = title;\r\n        inv.paid = false;\r\n\r\n        for (uint256 i = 0; i < items.length; i++) {\r\n            inv.items.push(\r\n                Item(\r\n                    items[i].description,\r\n                    items[i].quantity,\r\n                    items[i].unitPrice\r\n                )\r\n            );\r\n        }\r\n\r\n        ownerInvoices[msg.sender].push(invoiceId);\r\n    }\r\n\r\n    function deleteInvoice(uint256 invoiceId) external {\r\n        Invoice storage inv = invoices[invoiceId];\r\n        require(inv.owner != address(0), \"Invoice does not exist\");\r\n        require(inv.owner == msg.sender || (inv.payer == msg.sender && inv.paid == true), \"Can't delete invoice\");\r\n\r\n        // Save before delete\r\n        address owner = inv.owner;\r\n        address payer = inv.payer;\r\n\r\n        // Delete invoice\r\n        delete invoices[invoiceId];\r\n\r\n        // Remove from owner's list\r\n        _removeId(ownerInvoices[owner], invoiceId);\r\n\r\n        // Remove from payer's attributed list\r\n        if (payer != address(0)) {\r\n            _removeId(attributedInvoice[payer], invoiceId);\r\n        }\r\n    }\r\n\r\n    // Add an item to an invoice\r\n    function addItem(\r\n        uint256 invoiceId,\r\n        string memory description,\r\n        uint256 quantity,\r\n        uint256 unitPrice\r\n    ) external {\r\n        Invoice storage inv = invoices[invoiceId];\r\n        require(inv.owner != address(0), \"Invoice does not exist\");\r\n        require(inv.owner == msg.sender, \"Not invoice owner\");\r\n        require(!inv.paid, \"Cannot modify paid invoice\");\r\n        inv.items.push(Item(description, quantity, unitPrice));\r\n    }\r\n\r\n    // Remove an item from an invoice by index\r\n    function removeItem(uint256 invoiceId, uint256 index) external {\r\n        Invoice storage inv = invoices[invoiceId];\r\n        require(inv.owner != address(0), \"Invoice does not exist\");\r\n        require(inv.owner == msg.sender, \"Not invoice owner\");\r\n        require(!inv.paid, \"Cannot modify paid invoice\");\r\n        require(index < inv.items.length, \"Index out of bounds\");\r\n\r\n        inv.items[index] = inv.items[inv.items.length - 1];\r\n        inv.items.pop();\r\n    }\r\n\r\n    // Get items of an invoice\r\n    function getItems(uint256 invoiceId) external view returns (Item[] memory) {\r\n        return invoices[invoiceId].items;\r\n    }\r\n\r\n    // Calculate total price of an invoice\r\n    function getTotalPrice(uint256 invoiceId) public view returns (uint256) {\r\n        Invoice storage inv = invoices[invoiceId];\r\n        require(inv.owner != address(0), \"Invoice does not exist\");\r\n\r\n        uint256 total = 0;\r\n        for (uint256 i = 0; i < inv.items.length; i++) {\r\n            total += inv.items[i].quantity * inv.items[i].unitPrice;\r\n        }\r\n        return total;\r\n    }\r\n\r\n    // Pay an invoice\r\n    function payInvoice(uint256 invoiceId) external payable nonReentrant {\r\n        Invoice storage inv = invoices[invoiceId];\r\n        require(inv.owner != address(0), \"Invoice does not exist\");\r\n\r\n        uint256 totalPrice = getTotalPrice(invoiceId);\r\n\r\n        if (inv.payer != address(0)) {\r\n            require(\r\n                msg.sender == inv.payer,\r\n                \"You are not authorized to pay this invoice\"\r\n            );\r\n        }\r\n        require(msg.value >= totalPrice, \"Insufficient payment\");\r\n        require(!inv.paid, \"Invoice already paid\");\r\n        \r\n        // Mark invoice as paid\r\n        inv.paid = true;\r\n\r\n        // Transfer payment to invoice owner\r\n        (bool transferSuccess, ) = payable(inv.owner).call{value: totalPrice}(\"\");\r\n        require(transferSuccess, \"Payment transfer failed\");\r\n\r\n        // Refund excess payment\r\n        if (msg.value > totalPrice) {\r\n            (bool refundSuccess, ) = payable(msg.sender).call{value: msg.value - totalPrice}(\"\");\r\n            require(refundSuccess, \"Payment transfer failed\");\r\n        }\r\n    }\r\n\r\n    // Get all invoices created by owner\r\n    function getInvoicesByOwner(\r\n        address owner\r\n    ) external view returns (Invoice[] memory) {\r\n        uint256[] memory ids = ownerInvoices[owner];\r\n        Invoice[] memory result = new Invoice[](ids.length);\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            result[i] = invoices[ids[i]];\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // Get attributed Invoice\r\n    function getAttributedInvoice(\r\n        address attributedAddress\r\n    ) external view returns (Invoice[] memory) {\r\n        uint256[] memory ids = attributedInvoice[attributedAddress];\r\n        Invoice[] memory result = new Invoice[](ids.length);\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            result[i] = invoices[ids[i]];\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // Helpers //\r\n    function _removeId(uint256[] storage arr, uint256 id) internal {\r\n        for (uint256 i = 0; i < arr.length; i++) {\r\n            if (arr[i] == id) {\r\n                arr[i] = arr[arr.length - 1];\r\n                arr.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n"
      }
    }
  }
}